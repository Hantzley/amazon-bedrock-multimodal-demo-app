import streamlit as st
import json
import os
import base64
import io
import time
import boto3
import random

from PIL import Image
st.set_page_config(
    page_title="Image to Image",
    layout="wide",
)

max_images = st.sidebar.slider('Number of images:', min_value=1, max_value=5, value=3, step=1)
cfg_scale = st.sidebar.slider('cfg_scale:', min_value=1.1, max_value=10.0, value=8.0, step=0.1)

c1, c2 = st.columns([1, 8])
with c1:
    st.image("./imgs/bedrock.png", width=100)

with c2:
    st.header("Image variation")
    st.caption("Using Amazon Titan image model in Bedrock")

# Initialize the Bedrock client
region_name = os.getenv('AWS_REGION', 'us-east-1')
boto3_bedrock = boto3.client(service_name='bedrock-runtime', region_name=region_name)

negative_prompts = [
    "poorly rendered",
    "poor background details",
    "poorly drawn mountains",
    "disfigured mountain features",
]


# List of target aspect ratios
aspect_ratios = {
    "1:1": (1, 1),
    "2:3": (2, 3),
    "3:2": (3, 2),
    "3:5": (3, 5),
    "5:3": (5, 3),
    "7:9": (7, 9),
    "9:7": (9, 7),
    "6:11": (6, 11),
    "11:6": (11, 6),
    "5:11": (5, 11),
    "11:5": (11, 5),
    "9:5": (9, 5),
    "16:9": (16, 9)
}

# Target picture sizes
target_sizes = [
    (1024, 1024), (768, 768), (512, 512), (768, 1152), (384, 576),
    (1152, 768), (576, 384), (768, 1280), (384, 640), (448, 576),
    (1152, 896), (576, 448), (768, 1408), (384, 704), (1408, 768),
    (704, 384), (640, 1408), (320, 704), (1408, 640), (704, 320),
    (1152, 640), (1173, 640)
]

def closest_aspect_ratio(width, height):
    min_diff = float('inf')
    closest_ratio = None
    
    for ratio, (w_ratio, h_ratio) in aspect_ratios.items():
        # Calculate the aspect ratio difference
        ratio_diff = abs((width / height) - (w_ratio / h_ratio))
        if ratio_diff < min_diff:
            min_diff = ratio_diff
            closest_ratio = ratio
            
    return closest_ratio

def image_to_base64(img) -> str:
    """Convert a PIL Image or local image file path to a base64 string for Amazon Bedrock"""
    if isinstance(img, str):
        if os.path.isfile(img):
            #print(f"Reading image from file: {img}")
            with open(img, "rb") as f:
                return base64.b64encode(f.read()).decode("utf-8")
        else:
            raise FileNotFoundError(f"File {img} does not exist")
    elif isinstance(img, Image.Image):
        #print("Converting PIL Image to base64 string")
        buffer = io.BytesIO()
        img.save(buffer, format="PNG")
        return base64.b64encode(buffer.getvalue()).decode("utf-8")
    else:
        raise ValueError(f"Expected str (filename) or PIL Image. Got {type(img)}")


def generate_images(model_id, body):
    """
    Generate an image using Amazon Titan Image Generator G1 model on demand.
    Args:
        model_id (str): The model ID to use.
        body (str) : The request body to use.
    Returns:
        image_bytes (bytes): The image generated by the model.
    """

    accept = "application/json"
    content_type = "application/json"

    response = boto3_bedrock.invoke_model(
        body=body, modelId=model_id, accept=accept, contentType=content_type
    )
    response_body = json.loads(response.get("body").read())

    base64_images = response_body.get("images")
    

    finish_reason = response_body.get("error")

    if finish_reason is not None:
        st.write(f"Image generation error. Error is {finish_reason}")
            
    return base64_images


col1, col2 = st.columns(2)

with col1:
   uploaded_file = st.file_uploader("Upload an image", type=["png", "jpg", "jpeg"])

if uploaded_file is not None:
    image = Image.open(uploaded_file)

    with col2:
        max_size = 1408

        # Get original dimensions
        width, height = image.size
        #st.write(f"Original Dimensions: {width}x{height}")
        
        if width > max_size or height > max_size:
            # Calculate the scaling factor
            if width > height:
                scale = max_size / width
            else:
                scale = max_size / height
            
            # Calculate new dimensions
            new_width = int(width * scale)
            new_height = int(height * scale)
            
            # Resize image
            image = image.resize((new_width, new_height))
            #st.write(f"Resized Dimensions: {new_width}x{new_height}")
        else:
            new_height = height
            new_width = width

        thumbnail_height = 100  # Set your desired height
        thumbnail_aspect_ratio = width / height
        thumbnail_width = int(thumbnail_height * thumbnail_aspect_ratio)

        st.image(image, width=thumbnail_width) # Display source image

        #st.write("Target Aspect Ratio",closest_aspect_ratio(new_width, new_height))

        closest_size = min(target_sizes, key=lambda x: ((x[0]-width)**2 + (x[1]-height)**2)**0.5)
        #st.write(f"Closest Target Size: {closest_size[0]}x{closest_size[1]}")

        target_sizes = ["1024x1024", "768x768", "512x512", "768x1152", 
                                                "384x576", "1152x768", "576x384", "768x1280", 
                                                "384x640", "448x576", "1152x896", "576x448",
                                                "768x1408", "384x704", "1408x768", "704x384",
                                                "640x1408", "320x704", "1408x640", "704x320",
                                                "1152x640", "1173x640"]

        image_size = st.selectbox("Target Image Size:",target_sizes, target_sizes.index(f"{closest_size[0]}x{closest_size[1]}"))


    init_image_b64 = image_to_base64(image)
    #st.write(init_image_b64[:80] + "...")    

    prompt = st.text_area("Prompt:", "High quality, with a dynamic and engaging background")

    if max_images > 1:
        button_label = "Generate Images"
    else:
        button_label = "Generate Image"

    if st.button(button_label, key=prompt):

        if prompt == "":        
            st.error("Please enter a valid prompt and select presets...")
        else:
            with st.spinner("Wait for it..."):
                
                start_time = time.time()

                model_id = 'amazon.titan-image-generator-v1'

                target_image_size = image_size.split("x")

                body = json.dumps({
                    "taskType": "IMAGE_VARIATION",
                    "imageVariationParams": {
                        "text": prompt,
                        "negativeText": ", ".join(negative_prompts),
                        "images": [init_image_b64],
                        "similarityStrength": 0.7,  # Range: 0.2 to 1.0
                    },
                    "imageGenerationConfig": {
                        "numberOfImages": max_images,
                        "height": int(target_image_size[1]),
                        "width": int(target_image_size[0]),
                        "cfgScale": 8.0,
                        "seed": random.randint(0,2147483646)
                    }
                })

                images = generate_images(model_id=model_id,
                                            body=body)
                
                image_headers = []
                for x in range(max_images):
                    image_headers.append(f"Image {x}")

                tabs = st.tabs(image_headers)
                
                for x in range(max_images):

                    base64_image = images[x]
                    base64_bytes = base64_image.encode('ascii')
                    image_bytes = base64.b64decode(base64_bytes)
                    image = Image.open(io.BytesIO(image_bytes))                    

                    with tabs[x]:
                        st.header(image_headers[x])
                        st.image(image)
                        

                execution_time = round(time.time() - start_time, 2)

                st.success("Done!")
                st.caption(f"Execution time: {execution_time} seconds")   